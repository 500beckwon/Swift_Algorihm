import UIKit

/*
 알고리즘
 어떤 목적을 달성하거나 결과물을 만들어내기 위해 겨처야 하는 일련의 과정
 
 가는 루트는 다양하며 여러가지 상황에 따른 알고리즘은 모두 다르다. 따라서 시간복잡도가 가장
 낮은 알고리즘을 선택하여 사용한다
 
 알고리즘의 실행시간
 
 1 .입력값의 크기에 따라 알고리즘의 실행시간을 검증해볼 수 있다.
 
 2. 입력값의 크기에 따른 함수의 증가량, 우리는 이것을 성장률이라고 부른다.
 이때 중요하지 않는 상수와 계수들을 제거하면 알고리즘의 실행시간에서 중요한
 성장률에 집중할 수있는데 이것을 점금적 표기법이라 부른다.
 여기서, 점근적이라는 의미는 가장 큰 영향을 주는 항만 계산한다는 의미다.
 
 점근적 표기법은 다음 세가지가 있는데 시간복잡도를 나타내는데 사용된다.

 최상의 경우 : 오메가 표기법 (Big-Ω Notation)
 평균의 경우 : 세타 표기법 (Big-θ Notation)
 최악의 경우 : 빅오 표기법 (Big-O Notation)
 */

/*
 빅오 표기법
 
 시간복잡도
 - 알고리즘의 실행 속도
 공간복잡도
- 알고리즘의 메모리 사용 정도
 
 
 시간복잡도를 구하는 요령

 하나의 루프를 사용하여 단일 요소 집합을 반복 하는 경우 : O (n)
 컬렉션의 절반 이상 을 반복 하는 경우 : O (n / 2) -> O (n)
 두 개의 다른 루프를 사용하여 두 개의 개별 콜렉션을 반복 할 경우 : O (n + m) -> O (n)
 두 개의 중첩 루프를 사용하여 단일 컬렉션을 반복하는 경우 : O (n²)
 두 개의 중첩 루프를 사용하여 두 개의 다른 콜렉션을 반복 할 경우 : O (n * m) -> O (n²)
 컬렉션 정렬을 사용하는 경우 : O(n*log(n))
 */


// O(1)

func sum1(n: Int) {
    var total = n * (n + 1) / 2
    print(total)
}

// O(n)

func sum2(n: Int) {
    var total = 0
    for i in 0..<n {
        total += i
    }
    print(total)
}

// O(n^2)

func sayHello(n: Int) {
    for _ in 0..<n {
        for _ in 0..<n {
            print("Hello!")
        }
    }
}
